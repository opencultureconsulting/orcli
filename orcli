#!/usr/bin/env bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
orcli_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli - OpenRefine command-line interface written in Bash\n"
    echo

  else
    printf "orcli - OpenRefine command-line interface written in Bash\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli [command]\n"
  printf "  orcli [command] --help | -h\n"
  printf "  orcli --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  import   import commands"
  echo "  list     list projects on OpenRefine server"
  echo "  info     show project metadata"
  echo "  export   export commands"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  OPENREFINE_URL"
    printf "    URL to OpenRefine server\n"
    printf "    Default: http://localhost:3333\n"
    echo
    # :command.usage_examples
    printf "Examples:\n"

    printf "  orcli import csv file\n"
    printf "  orcli import csv\n  \"https://github.com/LibraryCarpentry/lc-open-refine/raw/gh-pages/data/doaj-article-sample.csv\"\n"
    printf "  orcli list\n"
    printf "  orcli info \"doaj article sample csv\"\n"
    printf "  orcli export tsv \"doaj article sample csv\"\n"
    printf "  orcli export tsv \"doaj article sample csv\" --output doaj.tsv\n"
    echo
    # :command.footer
    printf "https://github.com/opencultureconsulting/orcli\n"
    echo

  fi
}

# :command.usage
orcli_import_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli import - import commands\n"
    echo

  else
    printf "orcli import - import commands\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli import [command]\n"
  printf "  orcli import [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  csv   import comma-separated values (CSV)"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
orcli_import_csv_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli import csv - import comma-separated values (CSV)\n"
    echo

  else
    printf "orcli import csv - import comma-separated values (CSV)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli import csv [FILE...] [options]\n"
  printf "  orcli import csv --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --separator SEPARATOR"
    printf "    character(s) that separates columns\n"
    printf "    Default: ,\n"
    echo

    # :flag.usage
    echo "  --encoding ENCODING"
    printf "    set character encoding\n"
    echo

    # :flag.usage
    echo "  --trimStrings"
    printf "    trim leading & trailing whitespace from strings\n"
    echo

    # :flag.usage
    echo "  --projectName PROJECTNAME"
    printf "    set a name for the OpenRefine project\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  FILE..."
    printf "    Path to one or more files or URLs. When FILE is -, read standard input.\n"
    printf "    Default: -\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  orcli import csv file\n"
    printf "  cat file | orcli import csv\n"
    printf "  orcli import csv file --separator ; --encoding ISO-8859-1 --trimStrings\n  --projectName example\n"
    printf "  orcli import csv\n  \"https://github.com/LibraryCarpentry/lc-open-refine/raw/gh-pages/data/doaj-article-sample.csv\"\n"
    echo

  fi
}

# :command.usage
orcli_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli list - list projects on OpenRefine server\n"
    echo

  else
    printf "orcli list - list projects on OpenRefine server\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli list\n"
  printf "  orcli list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
orcli_info_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli info - show project metadata\n"
    echo

  else
    printf "orcli info - show project metadata\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli info PROJECT\n"
  printf "  orcli info --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PROJECT"
    printf "    project name or id\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  info Clipboard\n"
    printf "  info 1234567890123\n"
    echo

  fi
}

# :command.usage
orcli_export_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli export - export commands\n"
    echo

  else
    printf "orcli export - export commands\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli export [command]\n"
  printf "  orcli export [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  tsv   export tab-separated values (TSV)"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
orcli_export_tsv_usage() {
  if [[ -n $long_usage ]]; then
    printf "orcli export tsv - export tab-separated values (TSV)\n"
    echo

  else
    printf "orcli export tsv - export tab-separated values (TSV)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  orcli export tsv PROJECT [options]\n"
  printf "  orcli export tsv --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --output FILE"
    printf "    Write to file instead of stdout\n"
    echo

    # :flag.usage
    echo "  --encoding ENCODING"
    printf "    set character encoding\n"
    printf "    Default: UTF-8\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PROJECT"
    printf "    project name or id\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  orcli export tsv Clipboard\n"
    printf "  orcli export tsv Clipboard --output clipboard.tsv\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/get_csrf.sh
# get CSRF token (introduced in OpenRefine 3.3)
# shellcheck shell=bash
function get_csrf() {
  local response
  if ! response="$(curl -fs "${OPENREFINE_URL}/command/core/get-csrf-token")"; then
    if ! response="$(curl -fs "${OPENREFINE_URL}/command/core/get-version")"; then
      error "no OpenRefine reachable/running at ${OPENREFINE_URL}"
    fi
  else
    if ! [[ "${response}" == '{"token":"'* ]]; then
      error "getting CSRF token failed!"
    fi
    echo "?csrf_token=$(echo "$response" | cut -d \" -f 4)"
  fi
}

# src/lib/get_id.sh
# get project id (derived from project name if needed)
# shellcheck shell=bash
function get_id() {
  local response
  local projects
  local ids
  if ! response="$(curl -fs --get "${OPENREFINE_URL}/command/core/get-all-project-metadata")"; then
    error "no OpenRefine reachable/running at ${OPENREFINE_URL}"
  fi
  if ! projects="$(echo "$response" | jq -r '.projects | keys[] as $k | "\($k):\(.[$k] | .name)"' | grep -e ":$1$" -e "^$1:")"; then
    error "project $1 not found"
  fi
  ids=$(echo "$projects" | cut -d : -f 1)
  if ! [[ "${#ids}" == 13 ]]; then
    error "multiple projects found" "$projects"
  fi
  echo "$ids"
}

# src/lib/init_import.sh
# common import tasks to support multiple files and URLs
# shellcheck shell=bash
function init_import() {
    local files
    local file
    local tmpdir
    # catch args, convert the space delimited string to an array
    files=()
    eval "files=(${args[file]})"
    # create tmp directory
    tmpdir="$(mktemp -d)"
    trap 'rm -rf "$tmpdir"' 0 2 3 15
    # download files if name starts with http:// or https://
    for i in "${!files[@]}"; do
        if [[ ${files[$i]} == "http://"* ]] || [[ ${files[$i]} == "https://"* ]]; then
            if ! curl -fs --location "${files[$i]}" >"${tmpdir}/${files[$i]##*/}"; then
                error "download of ${files[$i]} failed!"
            fi
            files[$i]="${tmpdir}/${files[$i]##*/}"
        fi
    done
    # create a zip archive if there are multiple files
    if [[ ${#files[@]} -gt 1 ]]; then
        file="$tmpdir/Untitled.zip"
        zip "$file" "${files[@]}"
    else
        file="${files[0]}"
    fi
    # basic post data
    if [[ ${file} == "-" ]]; then
        data+=("project-file=@-")
    else
        if ! path=$(readlink -e "${file}"); then
            error "file ${file} not found!"
        fi
        data+=("project-file=@${path}")
    fi
    if [[ ${args[--projectName]} ]]; then
        data+=("project-name=${args[--projectName]}")
    else
        if [[ ${file} == "-" ]]; then
            name="Untitled"
        else
            name="$(basename "${path}" | tr '.' ' ')"
        fi
        data+=("project-name=${name}")
    fi
}

# src/lib/logging.sh
# print messages to STDERR
# shellcheck shell=bash
function error() {
  echo >&2 "[$(date +'%Y-%m-%dT%H:%M:%S')] ERROR: $1"
  shift
  for msg in "$@"; do echo >&2 "$msg"; done
  exit 1
}
function log() {
  echo >&2 "[$(date +'%Y-%m-%dT%H:%M:%S')] $1"
  shift
  for msg in "$@"; do echo >&2 "$msg"; done
}

# src/lib/post_import.sh
# post to create-project endpoint and validate
# shellcheck shell=bash disable=SC2154
function post_import() {
    local curloptions
    local projectid
    local projectname
    local rows
    # post
    mapfile -t curloptions < <(for d in "$@"; do
        echo "--form"
        echo "$d"
    done)
    if ! redirect_url="$(curl -fs --write-out "%{redirect_url}\n" "${curloptions[@]}" "${OPENREFINE_URL}/command/core/create-project-from-upload$(get_csrf)")"; then
        error "import of ${args[file]} failed!"
    fi
    # validate
    projectid=$(cut -d '=' -f 2 <<<"$redirect_url")
    if [[ ${#projectid} != 13 ]]; then
        error "import of ${args[file]} failed!"
    fi
    projectname=$(curl -fs --get --data project="$projectid" "${OPENREFINE_URL}/command/core/get-project-metadata" | tr "," "\n" | grep name | cut -d ":" -f 2)
    projectname="${projectname:1:${#projectname}-2}"
    rows=$(curl -fs --get --data project="$projectid" --data limit=0 "${OPENREFINE_URL}/command/core/get-rows" | tr "," "\n" | grep total | cut -d ":" -f 2)
    if [[ "$rows" = "0" ]]; then
        error "import of ${args[file]} contains 0 rows!" "${redirect_url}" "name:${projectname}" "rows:${rows}"
    else
        log "import of ${args[file]} successful" "${redirect_url}" "name:${projectname}" "rows:${rows}"
    fi
}

# :command.command_functions

# :command.function
orcli_import_csv_command() {
  # src/import_csv_command.sh
  # shellcheck shell=bash

  # call init_import function to eval args and to set basic post data
  init_import

  # check if stdin is present if selected
  if [[ ${args[file]} == '-' ]] || [[ ${args[file]} == '"-"' ]] && [ -t 0 ]; then
      orcli_import_csv_usage
      exit 1
  fi

  # assemble specific post data (some options require json format)
  data+=("format=text/line-based/*sv")
  options='{ '
  options+="\"separator\": \"${args[--separator]}\""
  if [[ ${args[--encoding]} ]]; then
      options+=', '
      options+="\"encoding\": \"${args[--encoding]}\""
  fi
  if [[ ${args[--trimStrings]} ]]; then
      options+=', '
      options+="\"trimStrings\": true"
  fi
  options+=' }'
  data+=("options=${options}")

  # call post_import function to post data and validate results
  post_import "${data[@]}"
}

# :command.function
orcli_list_command() {
  # src/list_command.sh
  # get all project metadata and reshape json to print a list
  # shellcheck shell=bash
  if ! response="$(curl -fs --get "${OPENREFINE_URL}/command/core/get-all-project-metadata")"; then
    error "no OpenRefine reachable/running at ${OPENREFINE_URL}"
  else
    if [[ "${response}" == '{"projects":{}}' ]]; then
      log "${OPENREFINE_URL} contains zero projects"
    else
      echo "$response" | jq -r '.projects | keys[] as $k | "\($k):\(.[$k] | .name)"'
    fi
  fi
}

# :command.function
orcli_info_command() {
  # src/info_command.sh
  # shellcheck shell=bash disable=SC2154
  get_id "${args[project]}"
}

# :command.function
orcli_export_tsv_command() {
  # src/export_tsv_command.sh
  # shellcheck shell=bash
  projectid="$(get_id "${args[project]}")"
  separator='\t'

  # assemble specific post data (some options require json format)
  data+=("project=${projectid}")
  data+=("format=tsv")
  options='{ '
  options+="\"separator\": \"${separator}\""
  if [[ ${args[--encoding]} ]]; then
      options+=', '
      options+="\"encoding\": \"${args[--encoding]}\""
  fi
  options+=' }'
  data+=("options=${options}")

  # post
  mapfile -t curloptions < <(for d in "${data[@]}"; do
      echo "--data"
      echo "$d"
  done)
  if [[ ${args[--output]} ]]; then
      if ! mkdir -p "$(dirname "${args[--output]}")"; then
          error "unable to create parent directory for ${args[--output]}"
      fi
      curloptions+=("--output")
      curloptions+=("${args[--output]}")
  fi
  if ! curl -fs "${curloptions[@]}" "${OPENREFINE_URL}/command/core/export-rows"; then
      error "export of ${args[project]} failed!"
  else
      if [[ ${args[--output]} ]]; then
          log "export of ${args[project]} successful" "file:${args[--output]}" "rows:$(cat "${args[--output]}" | wc -l )"
      fi
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    orcli_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  export OPENREFINE_URL="${OPENREFINE_URL:-http://localhost:3333}"
  # :command.dependencies_filter
  if ! [[ -x "$(command -v curl)" ]]; then
    printf "missing dependency: curl\n"
    exit 1
  fi
  if ! [[ -x "$(command -v jq)" ]]; then
    printf "missing dependency: jq\n"
    exit 1
  fi
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  import )
    action="import"
    shift
    orcli_import_parse_requirements "$@"
    shift $#
    ;;

  list )
    action="list"
    shift
    orcli_list_parse_requirements "$@"
    shift $#
    ;;

  info )
    action="info"
    shift
    orcli_info_parse_requirements "$@"
    shift $#
    ;;

  export )
    action="export"
    shift
    orcli_export_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    orcli_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
orcli_import_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    orcli_import_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  csv )
    action="csv"
    shift
    orcli_import_csv_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    orcli_import_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
orcli_import_csv_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    orcli_import_csv_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="import csv"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --separator )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--separator]="$2"
        shift
        shift
      else
        printf "%s\n" "--separator requires an argument: --separator SEPARATOR"
        exit 1
      fi
      ;;

    # :flag.case
    --encoding )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--encoding]="$2"
        shift
        shift
      else
        printf "%s\n" "--encoding requires an argument: --encoding ENCODING"
        exit 1
      fi
      ;;

    # :flag.case
    --trimStrings )
      # :flag.conflicts
      args[--trimStrings]=1
      shift
      ;;

    # :flag.case
    --projectName )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--projectName]="$2"
        shift
        shift
      else
        printf "%s\n" "--projectName requires an argument: --projectName PROJECTNAME"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[file]+x} ]]; then
        # :argument.validations
        args[file]="\"$1\""
        shift
      else
        args[file]="${args[file]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[file]:-} ]] || args[file]="-"
  [[ -n ${args[--separator]:-} ]] || args[--separator]=","
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
orcli_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    orcli_list_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
orcli_info_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    orcli_info_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="info"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[project]+x} ]]; then
        # :argument.validations
        args[project]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[project]+x} ]]; then
    printf "missing required argument: PROJECT\nusage: orcli info PROJECT\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
orcli_export_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    orcli_export_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  tsv )
    action="tsv"
    shift
    orcli_export_tsv_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    orcli_export_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
orcli_export_tsv_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    orcli_export_tsv_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="export tsv"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --output )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output FILE"
        exit 1
      fi
      ;;

    # :flag.case
    --encoding )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--encoding]="$2"
        shift
        shift
      else
        printf "%s\n" "--encoding requires an argument: --encoding ENCODING"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[project]+x} ]]; then
        # :argument.validations
        args[project]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[project]+x} ]]; then
    printf "missing required argument: PROJECT\nusage: orcli export tsv PROJECT [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--encoding]:-} ]] || args[--encoding]="UTF-8"
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "import" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      orcli_import_usage
    else
      orcli_import_command
    fi

  elif [[ $action == "import csv" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      orcli_import_csv_usage
    else
      orcli_import_csv_command
    fi

  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      orcli_list_usage
    else
      orcli_list_command
    fi

  elif [[ $action == "info" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      orcli_info_usage
    else
      orcli_info_command
    fi

  elif [[ $action == "export" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      orcli_export_usage
    else
      orcli_export_command
    fi

  elif [[ $action == "export tsv" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      orcli_export_tsv_usage
    else
      orcli_export_tsv_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
